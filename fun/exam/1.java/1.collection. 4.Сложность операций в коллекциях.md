Сложность операций в коллекциях Java зависит от конкретной реализации интерфейсов (List, Set, Map и т.д.). Вот основные примеры:

---

### **1. Списки (List)**
#### **ArrayList**
- **get(int index)**: O(1) — прямой доступ по индексу.
- **add(E element)**:
  - В конец: O(1) (амортизированная сложность, так как возможно увеличение массива).
  - В середину: O(n) — сдвиг элементов.
- **remove(int index)**: O(n) — сдвиг элементов.
- **contains(Object o)**: O(n) — линейный поиск.

#### **LinkedList**
- **get(int index)**: O(n) — последовательный доступ.
- **add(E element)**:
  - В конец/начало: O(1).
  - В середину: O(n) (поиск позиции + O(1) вставка).
- **remove(int index)**: O(n) (поиск элемента + O(1) удаление).
- **contains(Object o)**: O(n).

---

### **2. Множества (Set)**
#### **HashSet**
- **add(E e)**: O(1) (в среднем), O(n) в худшем случае (коллизии).
- **remove(Object o)**: O(1).
- **contains(Object o)**: O(1).

#### **TreeSet** (на основе красно-черного дерева)
- **add(E e)**: O(log n).
- **remove(Object o)**: O(log n).
- **contains(Object o)**: O(log n).
- **first()/last()**: O(log n).

#### **LinkedHashSet**
- Сложность аналогична HashSet, но сохраняет порядок добавления.

---

### **3. Ассоциативные массивы (Map)**
#### **HashMap**
- **put(K key, V value)**: O(1) (в среднем), O(n) в худшем случае.
- **get(Object key)**: O(1).
- **remove(Object key)**: O(1).
- **containsKey(Object key)**: O(1).

#### **TreeMap** (на основе красно-черного дерева)
- **put(K key, V value)**: O(log n).
- **get(Object key)**: O(log n).
- **remove(Object key)**: O(log n).

#### **LinkedHashMap**
- Аналогично HashMap, но с поддержкой порядка элементов.

---

### **4. Очереди (Queue)**
#### **PriorityQueue** (куча)
- **offer(E e)**: O(log n).
- **poll()**: O(log n).
- **peek()**: O(1).

#### **ArrayDeque**
- **addFirst()/addLast()**: O(1).
- **removeFirst()/removeLast()**: O(1).

---

### **Ключевые выводы**
1. **ArrayList** быстрее для доступа по индексу, но медленнее при вставке/удалении в середине.
2. **LinkedList** эффективна при частых вставках/удалениях в начале/конце, но медленна для доступа по индексу.
3. **HashSet/HashMap** — оптимальны для операций поиска и добавления (в среднем O(1)).
4. **TreeSet/TreeMap** поддерживают порядок элементов за O(log n).
5. **При выборе коллекции** учитывайте частоту операций (добавление, удаление, поиск) и необходимость упорядочивания.

---

### **Пример для HashMap**
```java
Map<String, Integer> map = new HashMap<>();
map.put("key", 10); // O(1)
int value = map.get("key"); // O(1)
```

Всегда проверяйте документацию, так как сложность может меняться в зависимости от реализации и условий (например, коллизии в хэш-таблицах).