**Dynamic Proxies в Java** — это механизм создания объектов-посредников (_прокси_) во время выполнения, которые перехватывают вызовы методов и позволяют добавить дополнительную логику (например, логирование, проверки, кеширование). Они работают на основе **Java Reflection API** и используются для реализации аспектно-ориентированного программирования (AOP).

---

### Как работают Dynamic Proxies?
1. **Интерфейсы**: Прокси создаются только для интерфейсов. Класс `java.lang.reflect.Proxy` генерирует реализацию указанных интерфейсов.
2. **InvocationHandler**: Вся логика перехвата вызовов методов определяется в реализации интерфейса `InvocationHandler`, где метод `invoke` вызывается при каждом обращении к прокси.
3. **Reflection**: Через `Method.invoke()` вызов передается целевому объекту (если требуется).

---

### Пример создания Dynamic Proxy
```java
import java.lang.reflect.*;

// 1. Интерфейс, для которого создается прокси
interface Greeter {
    void greet(String name);
}

// 2. Реальная реализация интерфейса
class GreeterImpl implements Greeter {
    public void greet(String name) {
        System.out.println("Hello, " + name);
    }
}

// 3. Обработчик вызовов
class LoggingHandler implements InvocationHandler {
    private final Object target;

    public LoggingHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Вызов метода: " + method.getName());
        return method.invoke(target, args); // Делегирование вызова целевому объекту
    }
}

// 4. Создание прокси
public class ProxyExample {
    public static void main(String[] args) {
        Greeter realGreeter = new GreeterImpl();

        Greeter proxy = (Greeter) Proxy.newProxyInstance(
            Greeter.class.getClassLoader(), // Загрузчик классов
            new Class[]{Greeter.class},     // Список интерфейсов
            new LoggingHandler(realGreeter) // Обработчик
        );

        proxy.greet("Alice"); 
        // Вывод:
        // Вызов метода: greet
        // Hello, Alice
    }
}
```

---

### Ключевые компоненты
1. **`Proxy.newProxyInstance()`**  
   Создает прокси-объект, реализующий указанные интерфейсы. Параметры:
    - `ClassLoader`: загружает класс прокси.
    - `Class<?>[]`: массив интерфейсов для реализации.
    - `InvocationHandler`: обработчик логики.

2. **`InvocationHandler`**  
   Интерфейс с методом:
   ```java
   Object invoke(Object proxy, Method method, Object[] args) throws Throwable
   ```
    - `proxy`: ссылка на сам прокси-объект.
    - `method`: метод, который был вызван (через reflection).
    - `args`: аргументы вызова.

---

### Ограничения Dynamic Proxies
- **Только для интерфейсов**: Нельзя проксировать классы (для этого используют библиотеки вроде CGLib или Byte Buddy).
- **Производительность**: Вызовы через reflection медленнее прямых вызовов.
- **Исключения**: Проверяемые исключения в методах интерфейса должны быть обработаны в `invoke`.

---

### Применение в реальных проектах
1. **Фреймворки**:
    - Spring AOP для транзакций и безопасности.
    - Hibernate для ленивой загрузки данных (_lazy loading_).
2. **Логирование и мониторинг**.
3. **Кеширование** результатов методов.
4. **Удаленные вызовы** (RPC), например, в Java RMI.

---

### Reflection в Dynamic Proxies
Reflection используется для:
- Создания экземпляра прокси через `Proxy.newProxyInstance`.
- Анализа методов интерфейса (через `Method`).
- Делегирования вызова целевому объекту через `method.invoke()`.

---

### Итог
Dynamic Proxies — мощный инструмент для метапрограммирования в Java, позволяющий гибко управлять поведением объектов. Однако их следует применять аккуратно из-за накладных расходов и ограничений. Для сложных сценариев (прокси классов) используют расширенные библиотеки.