**Visibility (видимость) в Java** — это гарантия того, что изменения переменной, сделанные одним потоком, будут видны другим потокам.  
**`volatile`** — ключевое слово, которое обеспечивает видимость и запрещает переупорядочивание операций с памятью.

---

### **Что гарантирует `volatile`?**
1. **Видимость**:  
   Когда поток записывает значение в `volatile`-переменную, оно немедленно становится видимым для других потоков. Без `volatile` потоки могут кэшировать значение локально, и изменения не будут синхронизированы.

2. **Запрет переупорядочивания**:  
   Компилятор и процессор не могут переставлять операции с `volatile`-переменными относительно других операций с памятью. Это обеспечивает соблюдение **happens-before** (см. ниже).

---

### **Когда используется `volatile`?**
1. **Флаги завершения работы**  
   Пример: остановка потока через флаг `volatile boolean flag`.
   ```java
   class Worker implements Runnable {
       private volatile boolean running = true;
       public void stop() { running = false; }
       @Override
       public void run() {
           while (running) {
               // Работа потока
           }
       }
   }
   ```

2. **Простые shared-состояния**  
   Если переменная записывается одним потоком, а читается другими, и операции атомарны (например, присваивание `int`, `boolean`).

3. **Singleton с Double-Checked Locking**  
   `volatile` предотвращает публикацию частично инициализированного объекта:
   ```java
   class Singleton {
       private static volatile Singleton instance;
       public static Singleton getInstance() {
           if (instance == null) {
               synchronized (Singleton.class) {
                   if (instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

---

### **Ограничения `volatile`**
- **Не гарантирует атомарность**!  
  Например, операция `count++` не будет атомарной, даже если `count` объявлен как `volatile`. Для атомарных операций используйте `AtomicInteger`, `synchronized` и т.д.

---

### **Правило happens-before для `volatile`**
- **Запись в `volatile`** happens-before **чтение той же переменной**.  
  Это означает, что все изменения, сделанные до записи в `volatile`, станут видимыми после чтения `volatile`.

---

### **Сравнение с `synchronized`**
| `volatile` | `synchronized` |
|------------|----------------|
| Гарантирует видимость и порядок | Гарантирует видимость, порядок и **атомарность** |
| Не блокирует потоки | Блокирует потоки (взаимное исключение) |
| Подходит для простых сценариев | Подходит для сложных операций |

---

### **Пример без `volatile` (проблема видимости)**
```java
// Без volatile поток может никогда не увидеть изменение finished
boolean finished = false; // Должно быть volatile!

void thread1() {
    while (!finished) { /* Бесконечный цикл */ }
}

void thread2() {
    finished = true;
}
```

### **Итог**
- Используйте `volatile` для простых shared-переменных, где требуется видимость, но не атомарность.
- Если нужна атомарность — применяйте `synchronized` или классы из `java.util.concurrent.atomic`.