**Thread starvation** в Java — это ситуация, когда поток не может получить доступ к общим ресурсам или времени CPU, потому что другие потоки (часто с более высоким приоритетом или более агрессивной политикой планирования) постоянно монополизируют эти ресурсы. В результате "голодающий" поток не может прогрессировать в выполнении своей работы.

### Основные причины thread starvation:

1. **Несправедливое планирование потоков**  
   Потоки с высоким приоритетом могут постоянно получать время CPU, оставляя потоки с низким приоритетом без шансов на выполнение. В современных JVM это встречается реже, так как планировщики потоков стали умнее.

2. **Долгие блокировки в synchronized-блоках**  
   Если поток надолго захватывает монитор (через `synchronized`) и не отпускает его, другие потоки, ожидающие этот монитор, могут "голодать".

3. **Отсутствие fairness (честности) в Lock**  
   Например, `ReentrantLock` без включенного режима fairness (`new ReentrantLock(true)`) может позволять одним потокам постоянно "перехватывать" блокировку, пока другие ждут.

4. **Некорректная работа с wait/notify**  
   Если поток пропускает уведомление (например, из-за условия в цикле `while`), он может бесконечно ждать.

### Пример thread starvation:
```java
public class StarvationExample {
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> worker(), "High-Priority");
        Thread t2 = new Thread(() -> worker(), "Low-Priority");
        
        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);
        
        t1.start();
        t2.start();
    }

    public static void worker() {
        synchronized (lock) {
            while (true) {
                // Долгая работа с блокировкой
                System.out.println(Thread.currentThread().getName() + " работает");
            }
        }
    }
}
```
Здесь поток `t2` может никогда не получить доступ к `lock`, так как `t1` постоянно удерживает его.

### Как избежать thread starvation?
1. **Используйте `ReentrantLock` с fairness**
   ```java
   ReentrantLock fairLock = new ReentrantLock(true); // Чередование потоков
   ```
2. **Уменьшайте время удержания блокировок**  
   Разбивайте длинные операции на короткие этапы.
3. **Избегайте некорректных приоритетов потоков**  
   Не злоупотребляйте `setPriority()`.
4. **Используйте конструкции `java.util.concurrent`**  
   Например, `Semaphore`, `CountDownLatch` или неблокирующие коллекции.

### Разница между starvation и deadlock:
- **Starvation**: Поток ждет, но другие потоки работают.
- **Deadlock**: Все потоки заблокированы навсегда, ожидая друг друга.

Starvation сложнее обнаружить, так как программа может работать, но часть потоков "застрянет".