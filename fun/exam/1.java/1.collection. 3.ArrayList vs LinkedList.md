**Внутреннее устройство HashMap в Java**

HashMap — одна из самых популярных коллекций в Java, реализующая интерфейс `Map`. Она хранит данные в виде пар **ключ-значение** и использует **хэш-таблицу** для обеспечения быстрого доступа. Рассмотрим её устройство детально.

---

### **1. Основные компоненты**
- **Массив бакетов (bucket array)**:
    - Это основной массив `Node<K,V>[] table`, где каждый элемент (бакет) может содержать **связный список** или **дерево** (в Java 8+).
    - Индекс бакета вычисляется на основе хэш-кода ключа.
- **Node<K,V>**:
    - Статический вложенный класс, представляющий элемент HashMap.
    - Содержит поля: `hash`, `key`, `value`, `next` (ссылка на следующий узел в случае коллизии).

```java
static class Node<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    // ...
}
```

---

### **2. Принцип работы**
#### **Добавление элемента (put)**
1. **Вычисление хэша ключа**:
    - Для ключа вызывается метод `hashCode()`.
    - Полученный хэш преобразуется через **внутреннюю функцию** `hash()`, которая дополнительно обрабатывает хэш для уменьшения коллизий.
   ```java
   static final int hash(Object key) {
       int h;
       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   }
   ```
2. **Определение индекса бакета**:
    - Индекс = `hash & (n - 1)`, где `n` — размер массива `table` (степень двойки). Это эквивалентно `hash % n`, но работает быстрее.
3. **Обработка коллизий**:
    - Если бакет пуст — создается новый узел.
    - Если в бакете есть элементы:
        - **Сравнение хэшей и ключей** (через `equals()`).
        - Если ключ существует — значение обновляется.
        - Если нет — узел добавляется в конец списка или дерева.

#### **Изменение структуры при коллизиях**
- **Java 8+**:
    - При длине списка > 8 и общем размере таблицы ≥ 64, список преобразуется в **сбалансированное дерево** (красно-черное дерево). Это уменьшает сложность поиска с O(n) до O(log n).
    - Если размер дерева уменьшается до 6, оно преобразуется обратно в список.

---

### **3. Динамическое расширение (rehashing)**
- **Начальная емкость (capacity)**: По умолчанию 16.
- **Коэффициент загрузки (load factor)**: По умолчанию 0.75. Определяет, при какой заполненности таблица будет расширена.
- **Порог расширения**: `capacity * load factor`. При достижении этого порога размер массива удваивается, и все элементы **перераспределяются** (rehash). Индексы пересчитываются по формуле `новый_индекс = hash & (new_capacity - 1)`.

---

### **4. Особенности**
- **Ключ `null`**:
    - Хранится в бакете с индексом 0. Для него не вычисляется хэш.
- **Порядок элементов**:
    - Не гарантируется. В Java 8 из-за использования деревьев порядок может меняться.
- **Синхронизация**:
    - **Не потокобезопасна**. Для многопоточности используйте `ConcurrentHashMap` или `Collections.synchronizedMap()`.

---

### **5. Производительность**
- **В среднем**:
    - `put()`, `get()`, `remove()` — **O(1)**.
- **В худшем случае** (все ключи в одном бакете):
    - **O(n)** для списка, **O(log n)** для дерева (Java 8+).

---

### **6. Пример работы**
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("apple", 1);
```
1. Хэш ключа `"apple"` вычисляется через `hash()`.
2. Индекс бакета: `hash % 16`.
3. Если бакет пуст — создается узел `Node<String, Integer>`.

---

### **7. Важные замечания**
- **Переопределение `hashCode()` и `equals()`**:
    - Для корректной работы ключа эти методы должны быть согласованы.
    - Если `hashCode()` возвращает разные значения для одинаковых объектов, элемент не будет найден.
- **Изменяемые ключи**:
    - Не используйте изменяемые объекты в качестве ключей. Если хэш ключа изменится после добавления, элемент станет недоступен.

---

### **Заключение**
HashMap эффективна благодаря сочетанию хэш-таблицы, механизма разрешения коллизий и динамического расширения. Понимание её устройства помогает правильно использовать коллекцию и избегать проблем с производительностью.