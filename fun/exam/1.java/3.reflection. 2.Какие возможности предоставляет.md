**Java Reflection** — это механизм, позволяющий анализировать и изменять структуру и поведение классов, объектов, методов и полей **во время выполнения программы**. Вот ключевые возможности, которые он предоставляет:

---

### 1. **Анализ структуры классов**
- Получение информации о классе: имя, модификаторы, суперкласс, интерфейсы, аннотации.
- Пример:
  ```java
  Class<?> clazz = String.class;
  System.out.println("Имя класса: " + clazz.getName());
  ```

---

### 2. **Работа с полями (Fields)**
- Получение списка всех полей класса (включая приватные).
- Чтение и изменение значений полей, даже если они объявлены как `private`.
- Пример:
  ```java
  Field field = obj.getClass().getDeclaredField("fieldName");
  field.setAccessible(true); // Игнорирует модификатор доступа
  field.set(obj, newValue);
  ```

---

### 3. **Вызов методов (Methods)**
- Вызов методов по их имени, включая приватные.
- Работа с перегруженными методами.
- Пример:
  ```java
  Method method = clazz.getDeclaredMethod("methodName", paramTypes);
  method.setAccessible(true);
  Object result = method.invoke(obj, args);
  ```

---

### 4. **Создание объектов**
- Создание экземпляров классов через конструктор (в том числе приватный).
- Пример:
  ```java
  Constructor<?> constructor = clazz.getDeclaredConstructor();
  constructor.setAccessible(true);
  Object instance = constructor.newInstance();
  ```

---

### 5. **Динамическая работа с массивами**
- Создание массивов и доступ к их элементам через `java.lang.reflect.Array`.
- Пример:
  ```java
  int[] array = (int[]) Array.newInstance(int.class, 10);
  Array.set(array, 0, 42);
  ```

---

### 6. **Анализ аннотаций**
- Проверка наличия аннотаций у классов, полей, методов.
- Пример:
  ```java
  if (clazz.isAnnotationPresent(MyAnnotation.class)) {
      MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
  }
  ```

---

### 7. **Генерация прокси-объектов**
- Создание динамических прокси через `java.lang.reflect.Proxy` для реализации интерфейсов "на лету".
- Пример:
  ```java
  InvocationHandler handler = (proxy, method, args) -> { ... };
  MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
      clazz.getClassLoader(), new Class[]{MyInterface.class}, handler);
  ```

---

### 8. **Модификация поведения**
- Изменение модификаторов доступа (`setAccessible(true)`).
- Динамическая обработка исключений, типов данных.

---

### **Ограничения и риски**
- **Производительность**: Операции через Reflection медленнее прямых вызовов.
- **Безопасность**: Требуются права `SecurityManager`.
- **Инкапсуляция**: Нарушает принципы ООП, так как позволяет обходить `private`.
- **Стабильность**: Ошибки (например, `NoSuchMethodException`) обнаруживаются только в runtime.

---

### **Пример использования**
```java
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        // Получение класса
        Class<?> clazz = Class.forName("java.util.ArrayList");

        // Создание экземпляра
        List<String> list = (List<String>) clazz.getDeclaredConstructor().newInstance();

        // Вызов метода add через Reflection
        Method addMethod = clazz.getMethod("add", Object.class);
        addMethod.invoke(list, "Hello Reflection!");

        System.out.println(list); // [Hello Reflection!]
    }
}
```

---

**Применение в реальных проектах**:
- Фреймворки (Spring, Hibernate) для инъекции зависимостей и ORM.
- Тестирование (доступ к приватным методам в unit-тестах).
- Сериализация/десериализация (Jackson, GSON).
- Инструменты анализа кода (например, IDE).