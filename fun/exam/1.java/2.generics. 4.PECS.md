**PECS (Producer Extends, Consumer Super)** — это мнемоническое правило в Java, которое помогает корректно использовать **дженерики (generics)** с вайлдкардами (`? extends` и `? super`). Оно определяет, когда использовать `extends` и `super` в контекстах, где тип данных производит (producer) или потребляет (consumer) значения.

### Контекст PECS
Правило применяется в обобщенных типах, таких как коллекции, чтобы обеспечить гибкость и безопасность типов. Рассмотрим на примере интерфейса `List<T>`:

---

### 1. **Producer Extends** (Поставщик использует `extends`)
Если структура **производит** (возвращает) элементы типа `T`, используйте `? extends T`. Это позволяет принимать:
- Сам тип `T`.
- Любой его **подтип** (наследник).

**Пример:**
```java
public void processNumbers(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num.doubleValue()); // Безопасное чтение
    }
    // list.add(new Integer(1)); // Ошибка компиляции! Нельзя добавлять элементы.
}
```
- **Можно**: Читать элементы как тип `Number` (безопасно, так как все подтипы `Number` имеют методы `doubleValue()`).
- **Нельзя**: Добавлять элементы (кроме `null`), так как компилятор не знает точный тип.

**Где использовать:** Методы, которые только читают данные из коллекции (например, итерация).

---

### 2. **Consumer Super** (Потребитель использует `super`)
Если структура **потребляет** (принимает) элементы типа `T`, используйте `? super T`. Это позволяет принимать:
- Сам тип `T`.
- Любой его **супертип** (родительский класс).

**Пример:**
```java
public void addIntegers(List<? super Integer> list) {
    list.add(new Integer(42)); // Безопасное добавление
    // Integer value = list.get(0); // Ошибка: тип элемента неизвестен (может быть Object).
}
```
- **Можно**: Добавлять элементы типа `Integer` (и его подтипы), так как коллекция гарантированно хранит `Integer` или его супертипы.
- **Нельзя**: Безопасно читать элементы (кроме `Object`), так как тип не определен.

**Где использовать:** Методы, которые записывают данные в коллекцию (например, добавление элементов).

---

### Пример из стандартной библиотеки: `Collections.copy()`
```java
public static <T> void copy(
    List<? extends T> src, // producer: возвращает T
    List<? super T> dest // consumer: принимает T
) {
    for (int i = 0; i < src.size(); i++) {
        dest.set(i, src.get(i)); // Безопасно: src производит T, dest потребляет T
    }
}
```
- `src` — **producer**, поэтому `extends`.
- `dest` — **consumer**, поэтому `super`.

---

### Итог
- **PECS** упрощает запоминание правил использования вайлдкардов.
- **`extends`** для чтения (producer), **`super`** для записи (consumer).
- Если коллекция одновременно и читает, и пишет — не используйте вайлдкарды (указывайте конкретный тип, например, `List<T>`).

Правило помогает избежать ошибок компиляции и делает код более гибким при работе с наследниками и общими типами.