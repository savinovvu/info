**ForkJoinPool** — это специальный пул потоков в Java, оптимизированный для рекурсивного разделения задач на подзадачи (fork) и последующего объединения результатов (join). Он реализует алгоритм **work-stealing**, где свободные потоки "крадут" задачи у занятых, что повышает эффективность параллельной обработки. Появился в Java 7 как часть фреймворка `Fork/Join`.

### Как работает ForkJoinPool?
1. **Рекурсивное разделение задач**: Большая задача разбивается на более мелкие подзадачи (например, через `RecursiveTask` или `RecursiveAction`).
2. **Work-Stealing**: Каждый поток имеет свою очередь задач. Если у потока заканчиваются задачи, он берет задачу из очереди другого потока.
3. **Параллелизм**: Подзадачи выполняются параллельно, а результаты объединяются.

Пример:
```java
class SumTask extends RecursiveTask<Long> {
    private final long[] numbers;
    private final int start, end;

    @Override
    protected Long compute() {
        if (end - start <= 10_000) { // Порог для последовательного выполнения
            return sequentialSum();
        }
        int mid = (start + end) / 2;
        SumTask left = new SumTask(numbers, start, mid);
        SumTask right = new SumTask(numbers, mid, end);
        left.fork(); // Асинхронный запуск левой подзадачи
        return right.compute() + left.join(); // Объединение результатов
    }
}
```

### Связь с `parallel()` в Stream API
В Java 8 Stream API использует `ForkJoinPool` для параллельных операций:
- При вызове `.parallel()` на стриме, задачи распределяются через **общий пул (ForkJoinPool.commonPool())**.
- Каждый элемент стрима обрабатывается в отдельной подзадаче, что позволяет ускорить обработку больших коллекций.

Пример:
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
long sum = list.parallelStream() // Использует ForkJoinPool.commonPool()
               .mapToLong(i -> i)
               .sum();
```

### Ключевые особенности:
1. **Общий пул по умолчанию**:
    - `ForkJoinPool.commonPool()` создается JVM автоматически.
    - Размер пула зависит от числа ядер процессора (`Runtime.getRuntime().availableProcessors() - 1`).

2. **Кастомизация**:
    - Можно создать свой `ForkJoinPool` для изоляции задач:
      ```java
      ForkJoinPool customPool = new ForkJoinPool(4);
      long result = customPool.submit(() -> 
          list.parallelStream().mapToLong(i -> i).sum()
      ).get();
      ```

3. **Эффективность**:
    - Идеально подходит для рекурсивных и CPU-интенсивных задач.
    - Менее эффективен для I/O-операций (лучше использовать `CompletableFuture` с другими пулами).

### Важно:
- **Не блокируйте потоки** в `ForkJoinPool`, так как это может привести к зависаниям.
- Для асинхронных задач с ожиданием (I/O) используйте отдельные пулы (например, `Executors.newCachedThreadPool()`).

Таким образом, `ForkJoinPool` — это основа для параллельных стримов в Java, обеспечивающая эффективное использование ресурсов многоядерных систем.