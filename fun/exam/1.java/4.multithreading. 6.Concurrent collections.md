Concurrent collections в Java — это набор потокобезопасных классов из пакета `java.util.concurrent`, предназначенных для работы в многопоточной среде без явной синхронизации. Они решают проблемы производительности и риски состояний гонки, присущие традиционным коллекциям (например, `ArrayList` или `HashMap`).

---

### **Основные типы Concurrent Collections**

#### 1. **ConcurrentHashMap**
- **Потокобезопасный аналог `HashMap`**, но с лучшей производительностью за счет сегментирования (разбиения данных на части).
- **Особенности**:
    - Не блокирует всю таблицу при записи (использует блокировки на уровне сегментов или CAS-операции).
    - Итераторы не бросают `ConcurrentModificationException` и отражают состояние на момент создания.
    - Методы `compute()`, `merge()` и `search()` для атомарных операций.
- **Пример**:
  ```java
  ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
  map.put("key", 1);
  map.compute("key", (k, v) -> v + 1); // Атомарное обновление
  ```

#### 2. **CopyOnWriteArrayList**
- **Потокобезопасный список**, где все изменяющие операции (add, set, remove) создают новую копию внутреннего массива.
- **Особенности**:
    - Идеален для сценариев с частым чтением и редкой записью.
    - Итераторы используют неизменяемый снимок данных на момент создания.
    - Дорогие операции записи из-за копирования.
- **Пример**:
  ```java
  CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
  list.add("element");
  for (String s : list) { // Итератор работает с копией
      System.out.println(s);
  }
  ```

#### 3. **CopyOnWriteArraySet**
- Аналог `CopyOnWriteArrayList`, реализующий интерфейс `Set`.
- **Особенности**:
    - Потокобезопасность достигается за счет внутреннего использования `CopyOnWriteArrayList`.
    - Подходит для небольших наборов данных с редкими изменениями.

#### 4. **ConcurrentLinkedQueue**
- **Неблокирующая потокобезопасная очередь** на основе связного списка.
- **Особенности**:
    - Использует алгоритмы без блокировок (CAS — Compare-And-Swap).
    - Подходит для высококонкурентных сценариев.
    - Нет поддержки ограничения размера (в отличие от `ArrayBlockingQueue`).

#### 5. **BlockingQueue и ее реализации**
Интерфейс для очередей, которые блокируют поток при добавлении/извлечении, если очередь пуста/полна.

- **ArrayBlockingQueue**:
    - Очередь на основе массива с фиксированной емкостью.
    - Использует единую блокировку (производительность ниже, чем у `ConcurrentLinkedQueue`).

- **LinkedBlockingQueue**:
    - Очередь на основе связного списка с опциональной ограниченной емкостью.
    - Использует две блокировки (для head и tail), что повышает параллелизм.

- **PriorityBlockingQueue**:
    - Потокобезопасная версия `PriorityQueue` с приоритетной ordering.

- **Пример использования**:
  ```java
  BlockingQueue<String> queue = new LinkedBlockingQueue<>();
  // Producer
  queue.put("item");
  // Consumer
  String item = queue.take();
  ```

#### 6. **ConcurrentSkipListMap и ConcurrentSkipListSet**
- Потокобезопасные аналоги `TreeMap` и `TreeSet`, основанные на структуре данных **SkipList**.
- **Особенности**:
    - Элементы хранятся в отсортированном порядке.
    - Поддерживают атомарные операции и неблокирующий доступ.

---

### **Ключевые преимущества**
1. **Потокобезопасность**: Не требуют внешней синхронизации.
2. **Производительность**: Используют сегментирование, CAS-операции и неблокирующие алгоритмы.
3. **Атомарные операции**: Методы типа `putIfAbsent()`, `compute()` и `merge()`.
4. **Слабосогласованные итераторы**: Не бросают `ConcurrentModificationException`.

---

### **Сравнение с синхронизированными коллекциями**
| **Параметр**          | **Синхронизированные коллекции** (e.g., `Collections.synchronizedList`) | **Concurrent Collections** |
|------------------------|-------------------------------------------------------------------------|----------------------------|
| **Блокировка**         | Глобальная блокировка на всю коллекцию                                 | Сегментированная или CAS   |
| **Производительность** | Низкая при высокой конкуренции                                         | Высокая                   |
| **Итераторы**          | Требуют ручной синхронизации                                           | Weakly consistent         |

---

### **Когда что использовать?**
- **ConcurrentHashMap**: Высококонкурентные сценарии с частыми обновлениями.
- **CopyOnWriteArrayList**: Частое чтение, редкая запись (например, списки слушателей событий).
- **BlockingQueue**: Паттерн «Producer-Consumer».
- **ConcurrentLinkedQueue**: Неблокирующие операции в высококонкурентной среде.

---

### **Пример Producer-Consumer с BlockingQueue**
```java
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);

// Producer
new Thread(() -> {
    try {
        queue.put(1);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();

// Consumer
new Thread(() -> {
    try {
        Integer value = queue.take();
        System.out.println("Consumed: " + value);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```

Concurrent collections — важный инструмент для разработки многопоточных приложений в Java, сочетающий безопасность и производительность.