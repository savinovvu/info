**Type Erasure (стирание типов)** в Java — это процесс, при котором компилятор удаляет информацию о generic-типах во время компиляции, чтобы обеспечить совместимость с кодом, написанным до введения дженериков (Java 5). Это важный аспект реализации дженериков в Java, который имеет как преимущества, так и ограничения.

### Как работает Type Erasure?
1. **Замена параметров типов**:
    - Если параметр типа не имеет ограничений (например, `<T>`), он заменяется на `Object`.
    - Если параметр типа имеет ограничение (например, `<T extends Number>`), он заменяется на верхнюю границу (в данном случае `Number`).
    - Если параметр типа имеет несколько ограничений (`<T extends A & B>`), он заменяется на первое из них.

2. **Добавление приведений типов**:
    - Компилятор автоматически вставляет проверки и приведения типов там, где это необходимо, чтобы обеспечить типобезопасность.

3. **Генерация bridge-методов**:
    - Для сохранения полиморфизма в иерархиях наследования компилятор создает специальные методы-«мосты».

### Примеры Type Erasure
#### Пример 1: Базовое стирание
```java
// Исходный код
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// После компиляции (условно)
public class Box {
    private Object value; // T заменен на Object

    public void setValue(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}
```

#### Пример 2: Ограниченный параметр типа
```java
// Исходный код
public class NumericBox<T extends Number> {
    private T value;

    public T getValue() {
        return value;
    }
}

// После компиляции
public class NumericBox {
    private Number value; // T заменен на Number

    public Number getValue() {
        return value;
    }
}
```

### Последствия Type Erasure
1. **Невозможность использовать примитивные типы**:
    - Дженерики не работают с примитивами (например, `List<int>` недопустимо), так как `T` стирается до `Object`.

2. **Проверка типов только на этапе компиляции**:
    - Runtime-проверки невозможны. Например, нельзя создать экземпляр `T` или проверить `instanceof` для параметра типа:
      ```java
      if (list instanceof List<String>) // Ошибка компиляции!
      ```

3. **Невозможность перегрузки по параметрам типа**:
    - Методы `void print(List<String>)` и `void print(List<Integer>)` будут иметь одинаковую сигнатуру после стирания.

4. **Проблемы с массивами**:
    - Нельзя создать массивы generic-типов: `new T[]` запрещено.

### Bridge-методы
Компилятор генерирует bridge-методы для корректной работы полиморфизма. Например:
```java
// Исходный код
public interface Comparable<T> {
    int compareTo(T other);
}

public class String implements Comparable<String> {
    public int compareTo(String other) { ... }
}

// После компиляции
public class String implements Comparable {
    // Bridge-метод, сгенерированный компилятором
    public int compareTo(Object other) {
        return compareTo((String) other); // Вызывает оригинальный метод
    }

    public int compareTo(String other) { ... }
}
```

### Обход ограничений
1. **Передача `Class<T>`**:
   ```java
   public class Box<T> {
       private T value;
       private Class<T> type;

       public Box(Class<T> type) {
           this.type = type;
       }

       public T createInstance() throws Exception {
           return type.newInstance(); // Создание объекта через рефлексию
       }
   }
   ```

2. **Использование `@SuppressWarnings`**:
   ```java
   @SuppressWarnings("unchecked")
   public T[] createArray(int size) {
       return (T[]) new Object[size]; // Предупреждение подавлено
   }
   ```

### Итог
- **Type Erasure** — это компромисс между типобезопасностью и обратной совместимостью.
- Дженерики в Java остаются **«ненастоящими»** (в сравнении с C++ или C#), но обеспечивают безопасность типов на этапе компиляции.
- Понимание механизма стирания помогает избегать распространенных ошибок и использовать обходные методы для сложных сценариев.