**Runtime Annotations в Java: работа с Reflection (Middle)**

### 1. Что такое Runtime Annotations?
**Аннотации** — это метаданные, которые добавляются в код Java. Они не меняют логику программы напрямую, но могут быть обработаны на этапе компиляции или выполнения.  
**Runtime-аннотации** — это аннотации, которые сохраняются в скомпилированном классе и доступны через **Reflection** во время выполнения программы. Для этого используется мета-аннотация `@Retention(RetentionPolicy.RUNTIME)`.

### 2. Объявление Runtime-аннотации
```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME) // Важно: аннотация доступна в runtime
public @interface MyAnnotation {
    String value() default "default_value";
    int priority() default 1;
}
```

### 3. Использование Reflection для обработки аннотаций
Reflection позволяет анализировать классы, методы, поля и т.д. во время выполнения. Примеры:

#### **Анализ аннотаций на классе:**
```java
@MyAnnotation(value = "class_example", priority = 5)
public class MyClass {
    // ...
}

// Проверка аннотации класса
Class<MyClass> clazz = MyClass.class;
if (clazz.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
    System.out.println("Value: " + annotation.value()); // class_example
    System.out.println("Priority: " + annotation.priority()); // 5
}
```

#### **Аннотации методов:**
```java
public class MyClass {
    @MyAnnotation("method_example")
    public void myMethod() {}
}

// Чтение аннотации метода
Method method = clazz.getMethod("myMethod");
if (method.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation ann = method.getAnnotation(MyAnnotation.class);
    System.out.println(ann.value()); // method_example
}
```

#### **Аннотации полей:**
```java
public class MyClass {
    @MyAnnotation
    private String field;
}

// Обработка аннотаций полей
Field field = clazz.getDeclaredField("field");
if (field.isAnnotationPresent(MyAnnotation.class)) {
    // Логика обработки
}
```

### 4. Практические сценарии использования
- **Сериализация/Десериализация:** Аннотации определяют, как поля преобразуются в JSON/XML (как в Jackson).
- **Валидация данных:** Проверка условий на полях (например, `@NotNull`).
- **Зависимости (DI):** Фреймворки вроде Spring используют аннотации для внедрения зависимостей.
- **Тестирование:** JUnit использует `@Test` для определения тестов.

### 5. Пример: кастомная валидация
```java
// Аннотация для валидации
@Retention(RetentionPolicy.RUNTIME)
public @interface MinLength {
    int value() default 3;
}

// Класс с валидацией
class User {
    @MinLength(5)
    private String name;

    public User(String name) { this.name = name; }
}

// Валидатор через Reflection
public static void validate(Object obj) throws Exception {
    for (Field field : obj.getClass().getDeclaredFields()) {
        if (field.isAnnotationPresent(MinLength.class)) {
            field.setAccessible(true);
            String value = (String) field.get(obj);
            MinLength ann = field.getAnnotation(MinLength.class);
            if (value.length() < ann.value()) {
                throw new IllegalArgumentException("Field " + field.getName() + " is too short");
            }
        }
    }
}
```

### 6. Производительность и ограничения
- **Минусы Reflection:**
    - Медленнее прямого вызова кода.
    - Нет проверки типов на этапе компиляции.
    - Может вызвать исключения в runtime (например, `NoSuchMethodException`).
- **Оптимизация:** Кеширование `Method`, `Field` объектов, использование библиотек (например, Spring AOP).

### 7. Итог
Runtime-аннотации + Reflection — мощный инструмент для создания гибких приложений, но требуют аккуратного использования. Они лежат в основе многих фреймворков, поэтому понимание их работы критично для Java-разработчиков среднего уровня.