**Ковариантность и контравариантность в Java** — это концепции, связанные с типизацией обобщений (generics) и подтипов. Они определяют, как соотносятся типы при использовании наследования и обобщенных классов. Разберем их на примерах.

---

### 1. **Инвариантность (Invariance)**
По умолчанию обобщенные типы в Java **инвариантны**. Это значит, что даже если класс `B` является подтипом `A`, то `Container<B>` **не** является подтипом `Container<A>`.

**Пример:**
```java
List<String> strings = new ArrayList<>();
List<Object> objects = strings; // Ошибка компиляции!
```
Компилятор запретит такое присваивание, так как `List<String>` не является подтипом `List<Object>`. Это предотвращает потенциальные ошибки:
```java
objects.add(123); // Если бы было разрешено, добавили бы Integer в List<String>
```

---

### 2. **Ковариантность (Covariance)**
Ковариантность позволяет использовать **более конкретный тип** вместо более общего. В Java это достигается через **wildcard** с `? extends`.

**Пример:**
```java
List<? extends Number> numbers = new ArrayList<Integer>(); // OK
```
Теперь `numbers` может ссылаться на список `Integer`, `Double` и т.д. Но есть ограничение:
```java
numbers.add(42); // Ошибка компиляции! Нельзя добавить элемент.
```
Почему? Компилятор не знает точный тип (`Integer`, `Double`?), и добавление может нарушить типобезопасность. Однако **чтение** разрешено:
```java
Number num = numbers.get(0); // OK
```

---

### 3. **Контравариантность (Contravariance)**
Контравариантность позволяет использовать **более общий тип** вместо более конкретного. Синтаксис: `? super`.

**Пример:**
```java
List<? super Integer> list = new ArrayList<Number>(); // OK
```
Здесь `list` может хранить `Integer` или его подтипы, но **чтение** ограничено:
```java
list.add(100); // OK, Integer совместим с ? super Integer
Object obj = list.get(0); // Тип только Object, так как ? super Integer
```
**Запись** разрешена для `Integer` и его подтипов, но при чтении можно получить только `Object`.

---

### 4. **PECS (Producer Extends, Consumer Super)**
Принцип использования вариативности:
- **Producer** (источник данных) → `? extends T`.
- **Consumer** (приемник данных) → `? super T`.

**Пример из Java Collections:**
```java
public static <T> void copy(
    List<? super T> dest, // Consumer: принимает T
    List<? extends T> src // Producer: возвращает T
) {
    for (int i = 0; i < src.size(); i++) {
        dest.add(src.get(i)); // Безопасно: src производит T, dest потребляет T
    }
}
```

---

### 5. **Ковариантность в массивах**
Массивы в Java **ковариантны**, что может привести к ошибкам времени выполнения:
```java
Integer[] ints = {1, 2, 3};
Object[] objects = ints;
objects[0] = "abc"; // ArrayStoreException в runtime!
```
В обобщениях такая ошибка предотвращается на этапе компиляции.

---

### Итог:
| Концепция       | Синтаксис      | Запись       | Чтение       | Пример использования |
|-----------------|----------------|--------------|--------------|----------------------|
| **Инвариантность** | `<T>`          | Разрешено    | Разрешено    | `List<String>`       |
| **Ковариантность** | `? extends T`  | Запрещено    | `T`          | Чтение из коллекции  |
| **Контравариантность** | `? super T` | `T` и подтипы | `Object`     | Запись в коллекцию   |

Вариативность в Java обеспечивает гибкость и типобезопасность, но требует внимательного подхода к работе с данными.


