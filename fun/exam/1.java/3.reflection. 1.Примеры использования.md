**Reflection в Java** позволяет анализировать и изменять структуру классов, методы, поля и конструкторы во время выполнения. Вот практические примеры:

---

### 1. **Получение информации о классе**
```java
Class<?> clazz = String.class;
System.out.println("Имя класса: " + clazz.getName());
System.out.println("Простые поля: " + Arrays.toString(clazz.getDeclaredFields()));
System.out.println("Методы: " + Arrays.toString(clazz.getDeclaredMethods()));
```
**Вывод:**  
Список всех полей и методов класса `String`.

---

### 2. **Создание экземпляра через конструктор**
```java
Class<?> clazz = ArrayList.class;
Constructor<?> constructor = clazz.getConstructor();
List<?> list = (List<?>) constructor.newInstance();
System.out.println("Создан: " + list.getClass().getSimpleName()); // Создан: ArrayList
```

---

### 3. **Вызов метода**
```java
String str = "Hello";
Method method = String.class.getMethod("toUpperCase");
String result = (String) method.invoke(str);
System.out.println(result); // HELLO
```

---

### 4. **Доступ к приватному полю**
```java
class Test {
    private String secret = "Секретное значение";
}

Test obj = new Test();
Field field = Test.class.getDeclaredField("secret");
field.setAccessible(true); // Игнорируем модификатор доступа
String value = (String) field.get(obj);
System.out.println(value); // Секретное значение
```

---

### 5. **Изменение приватного поля**
```java
field.setAccessible(true);
field.set(obj, "Новое значение");
System.out.println(field.get(obj)); // Новое значение
```

---

### 6. **Работа с аннотациями**
```java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String value();
}

class Demo {
    @MyAnnotation("Тест")
    public void method() {}
}

Method method = Demo.class.getMethod("method");
MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
System.out.println(annotation.value()); // Тест
```

---

### 7. **Анализ параметров метода**
```java
Method method = Math.class.getMethod("max", int.class, int.class);
System.out.println("Типы параметров: " + Arrays.toString(method.getParameterTypes())); // [int, int]
```

---

### 8. **Динамическая загрузка класса**
```java
Class<?> clazz = Class.forName("java.util.HashMap");
Object instance = clazz.getConstructor().newInstance();
System.out.println(instance instanceof Map); // true
```

---

### 9. **Обработка исключений Reflection**
```java
try {
    Field field = String.class.getDeclaredField("несуществующееПоле");
} catch (NoSuchFieldException e) {
    System.out.println("Поле не найдено: " + e.getMessage());
}
```

---

### 10. **Коллекции через Reflection**
```java
List<String> list = new ArrayList<>();
Method addMethod = List.class.getMethod("add", Object.class);
addMethod.invoke(list, "Элемент");
System.out.println(list); // [Элемент]
```

---

### **Важные предупреждения:**
1. **Производительность:** Reflection медленнее прямого вызова.
2. **Безопасность:** Обход инкапсуляции может нарушить логику программы.
3. **Компиляция:** Нет проверки типов на этапе компиляции.

Reflection используется в фреймворках (Spring, Hibernate), тестировании (JUnit) и сериализации. Применяйте его осторожно!