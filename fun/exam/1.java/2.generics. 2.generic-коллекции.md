Мы обсудим generic-коллекции в Java.

Generic-коллекции (или обобщенные коллекции) были введены в Java 5 для обеспечения типобезопасности и устранения необходимости приведения типов.
Они позволяют нам создавать коллекции, которые могут хранить элементы только определенного типа.

Основные преимущества:

Типобезопасность: мы не можем добавить элемент неправильного типа в generic-коллекцию.

Устранение приведения типов: нам не нужно явно приводить тип при извлечении элемента.

Пример без generics (до Java 5):

text
List list = new ArrayList();
list.add("hello");
String s = (String) list.get(0); // требуется приведение
С generics:

text
List<String> list = new ArrayList<>();
list.add("hello");
String s = list.get(0); // приведение не требуется
Основные generic-коллекции в Java:

List<E> - упорядоченная коллекция (список). Позволяет хранить дубликаты.
Реализации: ArrayList, LinkedList и др.

Set<E> - коллекция, которая не содержит дубликатов.
Реализации: HashSet, LinkedHashSet, TreeSet.

Queue<E> - коллекция, предназначенная для хранения элементов в порядке, готовом для обработки (обычно FIFO).
Реализации: LinkedList, PriorityQueue.

Map<K, V> - коллекция, которая хранит пары ключ-значение. Ключи уникальны.
Реализации: HashMap, LinkedHashMap, TreeMap.

Примеры:

List:

text
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
for (String fruit : list) {
System.out.println(fruit);
}
Set:

text
Set<Integer> set = new HashSet<>();
set.add(1);
set.add(2);
set.add(1); // не будет добавлено, так как уже есть
System.out.println(set.size()); // 2
Map:

text
Map<String, Integer> map = new HashMap<>();
map.put("one", 1);
map.put("two", 2);
int value = map.get("one"); // 1
Важно: при использовании generics мы не можем использовать примитивные типы (например, int, double). Вместо этого мы используем их обертки (Integer, Double).

Также можно использовать wildcards (подстановки) для большего flexibility:

<? extends T> - принимает любой тип, который является T или его подтипом (ковариантность).
<? super T> - принимает любой тип, который является T или его супертипом (контравариантность).
Например:

text
public void process(List<? extends Number> list) {
    // можем читать из list как Number
    for (Number n : list) {
        // ...
    }
    // но не можем добавлять (кроме null) потому что точный тип неизвестен
}
Еще одно важное понятие - type erasure (стирание типов). Generics в Java реализованы через стирание, что означает, что информация о типах удаляется во время компиляции и не доступна во время выполнения. Это означает, что, например, List<String> и List<Integer> во время выполнения становятся просто List.

Поэтому нельзя, например, создать массив generic-типа:

text
// Нельзя: 
List<String>[] arrayOfLists = new List<String>[10]; 
Но можно использовать коллекции с generics для создания типобезопасного кода.

Надеюсь, этот обзор поможет!

Generics (обобщения) в Java позволяют создавать типобезопасные коллекции, обеспечивая контроль над типами данных на этапе компиляции. Вот ключевые аспекты:

Основные Generic-коллекции
1. List (список)
java
List<String> stringList = new ArrayList<>();
stringList.add("Hello");
stringList.add("World");
// stringList.add(123); // Ошибка компиляции!

List<Integer> intList = new LinkedList<>();
intList.add(1);
intList.add(2);
2. Set (множество)
java
Set<Double> doubleSet = new HashSet<>();
doubleSet.add(3.14);
doubleSet.add(2.71);

Set<String> sortedSet = new TreeSet<>();
sortedSet.add("Zeta");
sortedSet.add("Alpha");
3. Map (словарь)
java
Map<Integer, String> map = new HashMap<>();
map.put(1, "One");
map.put(2, "Two");
// map.put("three", 3); // Ошибка компиляции!

Map<String, List<Integer>> complexMap = new HashMap<>();
Преимущества Generic-коллекций
Без generics (старый стиль)
java
List list = new ArrayList();
list.add("String");
list.add(123); // Разрешено, но опасно
String s = (String) list.get(1); // ClassCastException!
С generics (типобезопасность)
java
List<String> list = new ArrayList<>();
list.add("String");
// list.add(123); // Ошибка компиляции
String s = list.get(0); // Приведение не требуется
Wildcards (подстановки)
1. Upper bounded wildcard
java
// Принимает List любого типа, который является Number или его подтипом
public static double sum(List<? extends Number> list) {
    double sum = 0;
    for (Number n : list) {
        sum += n.doubleValue();
    }
    return sum;
}

List<Integer> ints = Arrays.asList(1, 2, 3);
List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
sum(ints);    // OK
sum(doubles); // OK
2. Lower bounded wildcard
java
// Принимает List Integer или его супертипов
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 5; i++) {
        list.add(i);
    }
}

List<Number> numbers = new ArrayList<>();
List<Object> objects = new ArrayList<>();
addNumbers(numbers); // OK
addNumbers(objects); // OK
3. Unbounded wildcard
java
// Принимает List любого типа
public static void printList(List<?> list) {
    for (Object elem : list) {
        System.out.println(elem);
    }
}
Создание собственных generic-классов
java
public class Box<T> {
private T value;

    public void setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}

// Использование
Box<String> stringBox = new Box<>();
stringBox.setValue("Hello");
Box<Integer> intBox = new Box<>();
intBox.setValue(42);
Generic-методы
java
public class Utils {
public static <T> void printArray(T[] array) {
for (T element : array) {
System.out.print(element + " ");
}
System.out.println();
}

    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
}

// Использование
String[] strings = {"A", "B", "C"};
Utils.printArray(strings);

Integer max = Utils.max(10, 20);
Best Practices
Всегда используйте generics для типобезопасности

Избегайте raw types (непараметризованных коллекций)

Используйте diamond operator <>

java
List<String> list = new ArrayList<>(); // вместо new ArrayList<String>()
Ограничивайте wildcards когда это необходимо для гибкости

Generics обеспечивают безопасность типов, устраняют необходимость явного приведения типов и делают код более читаемым и поддерживаемым.