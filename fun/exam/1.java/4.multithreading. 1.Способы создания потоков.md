В Java существует несколько способов создания и управления потоками. Вот основные подходы:

### 1. Наследование от класса `Thread`
```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Поток выполняется: " + Thread.currentThread().getName());
    }
}

// Использование
MyThread thread = new MyThread();
thread.start(); // Запуск потока
```

### 2. Реализация интерфейса `Runnable`
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Поток выполняется: " + Thread.currentThread().getName());
    }
}

// Использование
Thread thread = new Thread(new MyRunnable());
thread.start();
```

### 3. Лямбда-выражения (Java 8+)
```java
Thread thread = new Thread(() -> {
    System.out.println("Поток выполняется: " + Thread.currentThread().getName());
});
thread.start();
```

### 4. Использование `ExecutorService` (пулы потоков)
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Создание пула потоков
ExecutorService executor = Executors.newFixedThreadPool(5);

// Задача для выполнения
Runnable task = () -> System.out.println("Выполнение в пуле: " + Thread.currentThread().getName());

// Запуск задачи
executor.execute(task);

// Завершение работы пула
executor.shutdown();
```

### 5. Использование `Callable` и `Future`
Для задач, возвращающих результат:
```java
import java.util.concurrent.*;

Callable<String> task = () -> {
    Thread.sleep(1000);
    return "Результат выполнения";
};

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(task);

// Получение результата (блокирует поток до завершения)
String result = future.get(); 
System.out.println(result);

executor.shutdown();
```

### 6. Асинхронное выполнение с `CompletableFuture` (Java 8+)
```java
CompletableFuture
    .supplyAsync(() -> "Асинхронный результат")
    .thenAccept(result -> System.out.println("Обработка: " + result));
```

### 7. Фабричный метод `Thread.ofVirtual()` (виртуальные потоки, Java 21+)
```java
Thread virtualThread = Thread.ofVirtual()
    .name("virtual-thread")
    .start(() -> System.out.println("Виртуальный поток"));
```

### Ключевые различия:
- **Наследование vs Реализация**:  
  `Thread` — наследование, `Runnable` — композиция (более гибко).
- **Возврат результата**:  
  `Runnable` не возвращает результат, `Callable` — возвращает.
- **Пулы потоков**:  
  Эффективное управление ресурсами через `ExecutorService`.
- **Виртуальные потоки**:  
  Легковесные потоки для асинхронных задач (Java 19+ в preview, стабильно с Java 21).

### Пример с обработкой исключений
```java
Thread thread = new Thread(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // Корректная обработка прерывания
    }
});
```

### Важно:
- Всегда используйте `start()`, а не `run()` для запуска потока.
- Для потоков, выполняющих длительные операции, реализуйте механизм прерывания через `InterruptedException`.
- При работе с пулами потоков обязательно вызывайте `shutdown()`.

Выбор способа зависит от конкретной задачи:
- Простые задачи → `Runnable`/лямбда
- Возврат результата → `Callable`/`Future`
- Масштабируемость → `ExecutorService`
- Асинхронные цепочки → `CompletableFuture`
- Высокая нагрузка → виртуальные потоки (Java 21+)