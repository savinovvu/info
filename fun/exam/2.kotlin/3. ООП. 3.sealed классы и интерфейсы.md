**Sealed классы и интерфейсы** в Kotlin — это специальные конструкции, которые ограничивают наследование (для классов) или реализацию (для интерфейсов) определённым набором подтипов. Все подтипы должны быть объявлены **в том же пакете и модуле**, что и sealed-тип. Это позволяет компилятору знать все возможные варианты на этапе компиляции.

### Основные особенности:
- **Sealed классы** абстрактны по умолчанию, их нельзя инстанциировать напрямую.
- **Sealed интерфейсы** (появились в Kotlin 1.5) допускают только определённые реализации.
- Подтипы могут быть классами, object-ами, data-классами и т.д.

### Пример sealed класса:
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()
}
```

### Пример sealed интерфейса:
```kotlin
sealed interface Animal
class Dog : Animal
class Cat : Animal
```

---

### Преимущества в проектировании кода:
1. **Исчерпывающая проверка в `when`**  
   Компилятор проверяет, что все случаи sealed-типа обработаны в выражении `when`. Если какой-то кейс пропущен, произойдёт ошибка компиляции (если `when` используется как выражение) или предупреждение (если это statement).
   ```kotlin
   fun handleResult(result: Result<Data>) = when(result) {
        is Result.Success -> { ... }
        is Result.Error -> { ... }
        Result.Loading -> { ... }
        // else не требуется!
   }
   ```

2. **Безопасность и предотвращение ошибок**  
   Новые состояния нельзя добавить случайно — все подтипы фиксированы. Это особенно полезно для представления **ограниченного набора состояний** (например, состояние загрузки, успех, ошибка).

3. **Упрощение архитектуры**  
   Sealed-типы идеально подходят для моделирования иерархий, где все варианты известны заранее (например, события UI, AST в компиляторах, ответы сетевых запросов).

4. **Совместное использование с паттернами**  
   Отлично сочетаются с паттернами типа **Command**, **State Machine** или **Visitor**, заменяя громоздкие цепочки `if-else` на структурированные проверки.

---

### Пример использования в серверном Kotlin:
```kotlin
// Моделирование ответа API
sealed class ApiResponse<out T> {
    data class Success<T>(val data: T) : ApiResponse<T>()
    data class Failure(val error: String, val code: Int) : ApiResponse<Nothing>()
}

// Обработка ответа без риска упустить кейс
fun processResponse(response: ApiResponse<User>) = when(response) {
    is ApiResponse.Success -> saveUser(response.data)
    is ApiResponse.Failure -> logError(response.error)
}
```

---

### Отличия от enum:
- **Enum** — каждый элемент существует в единственном экземпляре.
- **Sealed-типы** — могут хранить состояние и иметь несколько экземпляров (например, `Success(data)` с разными данными).

---

### Заключение
Sealed-типы в Kotlin — это мощный инструмент для создания типобезопасных иерархий, которые делают код предсказуемым, удобным для рефакторинга и менее подверженным ошибкам. В серверной разработке они особенно полезны для обработки ответов API, управления состояниями и организации бизнес-логики.