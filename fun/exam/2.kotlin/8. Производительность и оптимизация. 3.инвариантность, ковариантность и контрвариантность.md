Объясню инвариантность, ковариантность и контравариантность в Kotlin на примере `List` и `MutableList`.

## 1. Инвариантность (Invariance)

**Инвариантность** означает, что типы должны точно совпадать. Если `Class<T>` инвариантен, то `Class<A>` не является подтипом `Class<B>`, даже если `A` является подтипом `B`.

**Пример с MutableList:**
```kotlin
fun addAnimals(animals: MutableList<Animal>) {
    animals.add(Dog())
}

// Не скомпилируется - MutableList инвариантен
val cats: MutableList<Cat> = mutableListOf(Cat())
addAnimals(cats) // ОШИБКА! Type mismatch
```

Почему это ошибка? Потому что если бы это было разрешено, мы могли бы добавить `Dog` в список `Cat`!

## 2. Ковариантность (Covariance)

**Ковариантность** сохраняет иерархию наследования. Если `Class<out T>` ковариантен, то `Class<A>` является подтипом `Class<B>`, когда `A` является подтипом `B`.

**Пример с List:**
```kotlin
// List объявлен как List<out E> - ковариантен
fun printAnimals(animals: List<Animal>) {
    animals.forEach { println(it.makeSound()) }
}

val cats: List<Cat> = listOf(Cat(), Cat())
printAnimals(cats) // OK! List ковариантен
```

**Почему List может быть ковариантным:**
- `List` только для чтения (read-only)
- Мы можем безопасно читать `Cat` как `Animal`
- Не можем добавлять элементы, поэтому типобезопасность сохраняется

## 3. Контравариантность (Contravariance)

**Контравариантность** обращает иерархию наследования. Если `Class<in T>` контравариантен, то `Class<B>` является подтипом `Class<A>`, когда `A` является подтипом `B`.

**Пример с Comparator:**
```kotlin
// Comparator объявлен как Comparator<in T> - контравариантен
fun sortDogs(dogComparator: Comparator<Dog>) {
    val dogs = listOf(Dog(), Dog())
    dogs.sortedWith(dogComparator)
}

val animalComparator = Comparator<Animal> { a1, a2 -> 
    a1.name.compareTo(a2.name)
}

sortDogs(animalComparator) // OK! Comparator контравариантен
```

## Сравнение в таблице:

| Концепция | Обозначение | Направление | Пример |
|-----------|-------------|-------------|---------|
| Инвариантность | `<T>` | Нет наследования | `MutableList<T>` |
| Ковариантность | `<out T>` | Сохраняет наследование | `List<out T>` |
| Контравариантность | `<in T>` | Обращает наследование | `Comparator<in T>` |

## Практическое применение:

```kotlin
open class Animal
class Cat : Animal()
class Dog : Animal()

// Ковариантность - безопасно возвращать T
interface Producer<out T> {
    fun produce(): T
}

// Контравариантность - безопасно потреблять T
interface Consumer<in T> {
    fun consume(item: T)
}

// Инвариантность - и потреблять, и возвращать T
interface Processor<T> {
    fun process(item: T): T
}
```

## Правила вариативности:

1. **Use-site variance** (объявление на месте использования):
```kotlin
fun copy(from: List<out Animal>, to: MutableList<in Animal>) {
    from.forEach { to.add(it) }
}
```

2. **Declaration-site variance** (объявление при декларации):
```kotlin
interface List<out E> { // Ковариантность объявлена здесь
    fun get(index: Int): E
}
```

Ключевое понимание: **ковариантность безопасна для "производства" (чтения), контравариантность - для "потребления" (записи), а инвариантность - для обоих случаев.**