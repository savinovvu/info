Делегирование в Kotlin — мощный инструмент для повторного использования кода и реализации паттерна делегирования. Рассмотрим два вида: **делегирование свойств** (включая `by lazy`) и **делегирование интерфейсов**.

---

### 1. Делегирование свойств с `by lazy`
`by lazy` используется для **ленивой инициализации** — значение вычисляется только при первом обращении к свойству.

#### Пример в серверном Kotlin:
```kotlin
class DatabaseConfig {
    val connectionString: String by lazy {
        // Имитация тяжелой инициализации (например, чтение из файла или env-переменных)
        println("Вычисление connectionString...")
        "jdbc:postgresql://localhost:5432/mydb"
    }
}

fun main() {
    val config = DatabaseConfig()
    println("Объект создан")
    println(config.connectionString) // Значение вычисляется здесь
    println(config.connectionString) // Возвращается кэшированный результат
}
```
**Вывод:**
```
Объект создан
Вычисление connectionString...
jdbc:postgresql://localhost:5432/mydb
jdbc:postgresql://localhost:5432/mydb
```

**Особенности:**
- Потокобезопасно по умолчанию (используется `LazyThreadSafetyMode.SYNCHRONIZED`).
- Идеально для ресурсоемких операций (например, подключение к БД).

---

### 2. Делегирование интерфейсов
Kotlin позволяет делегировать реализацию интерфейса другому объекту через `by`.

#### Пример для серверной части:
```kotlin
interface UserRepository {
    fun findUser(id: String): User?
}

class UserRepositoryImpl : UserRepository {
    override fun findUser(id: String): User? {
        return User(id, "John Doe")
    }
}

class CachedUserRepository(private val delegate: UserRepository) : UserRepository by delegate {
    private val cache = mutableMapOf<String, User?>()
    
    override fun findUser(id: String): User? {
        return cache.getOrPut(id) { delegate.findUser(id) }
    }
}

data class User(val id: String, val name: String)

fun main() {
    val realRepo = UserRepositoryImpl()
    val cachedRepo = CachedUserRepository(realRepo)
    
    println(cachedRepo.findUser("123")) // Вызывается метод с кэшированием
    println(cachedRepo.findUser("123")) // Данные берутся из кэша
}
```

**Преимущества:**
- Делегируем основную логику `UserRepositoryImpl`, добавляя кэширование.
- Не требуется явно реализовывать все методы интерфейса.

---

### 3. Кастомные делегаты свойств
Для создания собственного делегата нужно реализовать интерфейс `ReadOnlyProperty` (для `val`) или `ReadWriteProperty` (для `var`).

#### Пример: логирование доступа к свойству
```kotlin
class LoggedProperty<T>(private val initialValue: T) : ReadWriteProperty<Any?, T> {
    private var value: T = initialValue

    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        println("${property.name} = $value")
        return value
    }

    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        println("${property.name} изменяется на $value")
        this.value = value
    }
}

class Service {
    var requestCount: Int by LoggedProperty(0)
}

fun main() {
    val service = Service()
    service.requestCount = 1
    println(service.requestCount)
}
```

**Вывод:**
```
requestCount изменяется на 1
requestCount = 1
1
```

---

### Итог:
1. **`by lazy`** — для ленивой инициализации (например, подключения к БД).
2. **Делегирование интерфейсов** — для композиции и добавления поведения (кэширование, логирование).
3. **Кастомные делегаты** — для гибкого управления доступом к свойствам (валидация, наблюдение за изменениями).

Эти инструменты особенно полезны в серверном Kotlin для работы с ресурсами, кэшированием и модульностью кода.