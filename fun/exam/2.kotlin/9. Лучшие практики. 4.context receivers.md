**Контекстные ресиверы (context receivers)** — это экспериментальная функция Kotlin, которая позволяет объявлять зависимости от контекста (обычно представленного в виде `receiver`'ов) для функций, классов или свойств. Они полезны для неявной передачи контекстно-зависимых данных, таких как транзакции, скоупы зависимостей или настройки, без явного их указания в параметрах.

### Как это работает?
Синтаксис:
```kotlin
context(MyContext1, MyContext2) // Указываем требуемые контексты
fun myFunction() {
    // В этой области доступны неявные `this` для MyContext1 и MyContext2
    println(this@MyContext1.someProperty)
}
```

### Пример использования:
```kotlin
class DatabaseContext(val db: Database)
class LoggerContext(val logger: Logger)

context(DatabaseContext, LoggerContext)
fun saveUserData(user: User) {
    db.insert(user) // Используется DatabaseContext
    logger.log("User saved") // Используется LoggerContext
}

// Вызов функции требует наличия контекстов:
fun main() {
    val dbContext = DatabaseContext(database)
    val loggerContext = LoggerContext(logger)

    with(dbContext) {
        with(loggerContext) {
            saveUserData(user) // Контексты неявно передаются
        }
    }
}
```

### Для чего используются?
1. **Уменьшение шаблонного кода**:  
   Избавляют от необходимости явно передавать контексты через параметры функций.

2. **Создание DSL (Domain-Specific Language)**:  
   Позволяют строить декларативные API, где контекст определяет доступные операции. Например, в веб-фреймворках:
   ```kotlin
   context(RoutingContext)
   fun get(path: String, handler: () -> Unit) { ... }
   ```

3. **Управление зависимостями**:  
   В серверных приложениях помогают организовать внедрение контекстов (транзакции, сессии, запросы) без передачи их через все слои.

4. **Типобезопасность**:  
   Компилятор гарантирует, что функция вызвана в правильном контексте.

### Особенности:
- **Экспериментальный статус**: Требует явного включения через `@ContextReceivers` или флаг компилятора `-Xcontext-receivers`.
- **Множественные контексты**: Можно указать несколько контекстов через запятую.
- **Локальность**: Контексты должны быть предоставлены в области вызова (например, через `with`).

### Пример в серверном Kotlin:
```kotlin
context(TransactionContext, UserSession)
fun updateProfile(userId: String, newName: String) {
    executeQuery("UPDATE users SET name = ? WHERE id = ?", newName, userId)
    logAction("Profile updated for $userId") // logAction из UserSession
}

// Где-то в коде:
transaction {
    withUserSession(session) {
        updateProfile("123", "Alice")
    }
}
```

**Итог**: Контекстные ресиверы упрощают работу с зависимостями, делая код чище и выразительнее, особенно в сложных серверных приложениях. Однако из-за экспериментального статуса их следует использовать с осторожностью.