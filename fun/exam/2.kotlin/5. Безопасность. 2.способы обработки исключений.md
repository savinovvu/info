В Kotlin есть несколько способов обработки исключений. Разберем основные подходы и различия между `try-catch` и `runCatching`.

### 1. Базовый try-catch-finally
Классический способ, унаследованный из Java:
```kotlin
try {
    val result = riskyOperation()
    println(result)
} catch (e: IOException) {
    println("IO error: ${e.message}")
} catch (e: IllegalArgumentException) {
    println("Invalid argument: ${e.message}")
} finally {
    releaseResources()
}
```
**Особенности:**
- Множественные блоки `catch` для разных типов исключений
- Блок `finally` гарантированно выполняется
- Может использоваться как выражение (возвращает значение)

### 2. runCatching (функция-расширение)
Функциональный подход из стандартной библиотеки Kotlin:
```kotlin
val result = runCatching {
    riskyOperation()
}.onSuccess { value ->
    println("Success: $value")
}.onFailure { e ->
    println("Failed: ${e.message}")
}.getOrNull()
```

### Ключевые различия try-catch и runCatching

| Аспект | try-catch | runCatching |
|--------|-----------|-------------|
| **Стиль** | Императивный | Функциональный |
| **Возвращаемое значение** | Результат блока try/catch | Объект `Result<T>` |
| **Гибкость** | Прямой доступ к исключениям | Цепочка обработчиков |
| **Null-безопасность** | Требует ручной проверки | `getOrNull()` возвращает nullable |

### 3. Дополнительные возможности runCatching

**Преобразование результатов:**
```kotlin
val data = runCatching { apiCall() }
    .map { it.toDomainModel() }
    .recover { fallbackData }
    .getOrThrow()
```

**Обработка конкретных исключений:**
```kotlin
val result = runCatching { parseData(input) }
    .recoverCatch { e: NumberFormatException -> 
        handleNumberFormatError(e) 
    }
```

### 4. Рекомендации для серверной разработки

1. **Для ожидаемых ошибок** (валидация, бизнес-логика):
```kotlin
// Используйте sealed class для представления результатов
sealed class ApiResult<out T>
data class Success<T>(val value: T) : ApiResult<T>()
data class Error(val message: String) : ApiResult<Nothing>()

fun handleRequest(): ApiResult<Data> = try {
    Success(processRequest())
} catch (e: ValidationException) {
    Error("Validation failed: ${e.message}")
}
```

2. **Для критичных операций** используйте прямой try-catch:
```kotlin
fun databaseTransaction(block: () -> Unit) {
    try {
        transaction { block() }
    } catch (e: SQLException) {
        log.error("DB operation failed", e)
        throw e
    }
}
```

3. **Для цепочек преобразований** подходит runCatching:
```kotlin
fun processUserInput(input: String) = runCatching {
    input.trim()
}.mapCatching { it.toInt() }
 .map { it * 2 }
 .getOrElse { 0 }
```

### 5. Best Practices для серверного Kotlin

- **Логируйте исключения** на уровне контроллеров/интерцепторов
- **Используйте глобальные обработчики** исключений в веб-фреймворках
- **Разделяйте ожидаемые и системные ошибки**
- **Тестируйте исключения** с помощью `assertThrows`

```kotlin
// Пример с Spring Boot
@ControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(ServiceException::class)
    fun handleBusinessException(e: ServiceException): ResponseEntity<ErrorResponse> {
        return ResponseEntity.status(400).body(ErrorResponse(e.message))
    }
}
```

**Вывод:** Используйте `try-catch` для критичных участков кода, где важна детальная обработка исключений, и `runCatching` для функциональных цепочек преобразований с единообразной обработкой ошибок. В серверной разработке комбинируйте оба подхода в зависимости от контекста.