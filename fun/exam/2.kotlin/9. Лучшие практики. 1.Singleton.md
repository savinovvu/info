В Kotlin есть несколько способов реализации паттерна Singleton с учетом потокобезопасности и ленивой инициализации. Рассмотрим основные подходы:

### 1. **Object Declaration (Идиоматичный способ)**
Наиболее простой и потокобезопасный вариант, поддерживаемый на уровне языка:
```kotlin
object Singleton {
    fun doSomething() = println("Work done")
}
```
- **Потокобезопасность**: Гарантируется JVM (инициализация происходит при первем обращении).
- **Ленивая инициализация**: Да, экземпляр создается при первом обращении к `Singleton`.

### 2. **Lazy Delegate (Для кастомной логики)**
Если требуется ленивая инициализация с дополнительной логикой:
```kotlin
class Singleton private constructor() {
    companion object {
        val instance: Singleton by lazy {
            // Дополнительные действия при создании
            println("Creating instance")
            Singleton()
        }
    }
    
    fun doSomething() = println("Work done")
}
```
- **Потокобезопасность**: `by lazy` по умолчанию использует `LazyThreadSafetyMode.SYNCHRONIZED`.
- **Контроль над инициализацией**: Можно добавить кастомную логику внутри блока `lazy`.

### 3. **Double-Checked Locking (Для сложных случаев)**
Если нужна явная синхронизация или параметры инициализации:
```kotlin
class Singleton private constructor(
    private val config: String
) {
    companion object {
        @Volatile
        private var instance: Singleton? = null

        fun getInstance(config: String): Singleton =
            instance ?: synchronized(this) {
                instance ?: Singleton(config).also { instance = it }
            }
    }
    
    fun doSomething() = println("Config: $config")
}
```
- **Потокобезопасность**: Используется `synchronized` и `@Volatile`.
- **Ленивость**: Экземпляр создается только при первом вызове `getInstance`.

### 4. **Initialization-on-Demand Holder (Оптимизированный вариант)**
Паттерн "ленивый держатель" для статической инициализации:
```kotlin
class Singleton private constructor() {
    companion object {
        val instance: Singleton by lazy { Holder.INSTANCE }
    }
    
    private object Holder {
        val INSTANCE = Singleton()
    }
}
```
- **Потокобезопасность**: Гарантируется JVM при инициализации статического поля `Holder`.
- **Эффективность**: Не требует синхронизации при каждом обращении.

### Рекомендации для серверного Kotlin:
1. **Используйте `object`** для простых случаев без параметров инициализации.
2. **`by lazy`** подходит для большинства scenarios с ленивой инициализацией.
3. **Избегайте ручной реализации** double-checked locking, если нет особых требований.
4. **Для зависимостей** в серверных приложениях рассмотрите использование DI-фреймворков (Koin, Spring).

Пример использования в серверном контексте:
```kotlin
object DatabaseConfig {
    val connectionUrl: String by lazy {
        System.getenv("DB_URL") ?: "jdbc:postgresql://localhost:5432/app"
    }
}

object Logger {
    fun log(message: String) = println("[INFO] $message")
}
```