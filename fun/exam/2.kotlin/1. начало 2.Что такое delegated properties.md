**Delegated properties** (делегированные свойства) в Kotlin — это механизм, который позволяет делегировать методы доступа (геттеры и сеттеры) свойства другому объекту. Это полезно для повторного кода, ленивой инициализации, наблюдения за изменениями и других задач. В серверном Kotlin (например, в Spring Boot, Ktor) этот механизм активно используется для упрощения работы с конфигурацией, зависимостями, базами данных и т.д.

### Основные концепции
Делегирование свойств реализуется через ключевое слово `by`. Стандартная библиотека Kotlin предоставляет несколько встроенных делегатов, таких как:
1. **lazy** — отложенная инициализация.
2. **observable** — отслеживание изменений свойства.
3. **vetoable** — возможность отклонить изменение свойства.
4. **notNull** — свойство не может быть `null`.

### Примеры в серверном контексте

#### 1. Ленивая инициализация (Lazy)
Полезно для тяжелых ресурсов (например, подключение к БД), которые нужно инициализировать только при первом доступе.
```kotlin
class DatabaseService {
    val connection: Connection by lazy {
        DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydb")
    }
}
```

#### 2. Наблюдение за изменениями (Observable)
Например, для логирования изменений конфигурации.
```kotlin
class AppConfig {
    var port by Delegates.observable(8080) { _, old, new ->
        println("Port changed from $old to $new")
    }
}
```

#### 3. Работа с картами (Map)
Удобно для парсинга конфигурационных файлов (например, YAML/JSON).
```kotlin
class ServerConfig(configMap: Map<String, Any>) {
    val host: String by configMap
    val port: Int by configMap
}

// Использование
val config = mapOf("host" to "localhost", "port" to 8080)
val serverConfig = ServerConfig(config)
println(serverConfig.host) // "localhost"
```

#### 4. Кастомные делегаты
Можно создавать собственные делегаты для специфичных задач. Например, для инъекции зависимостей:
```kotlin
class DependencyDelegate<T>(private val provider: () -> T) : ReadOnlyProperty<Any?, T> {
    private var value: T? = null

    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        if (value == null) {
            value = provider()
        }
        return value!!
    }
}

class UserService {
    val database: Database by DependencyDelegate { Database.connect() }
}
```

### Применение в серверных фреймворках
- **Spring Boot**: Упрощение работы с `@ConfigurationProperties`.
- **Ktor**: Делегаты для работы с параметрами запроса, сессиями.
- **Exposed (ORM)**: Ленивая загрузка связей между сущностями.

### Пример с Ktor
```kotlin
routing {
    get("/user/{id}") {
        val id: String by call.parameters // Делегат для параметров запроса
        val user = getUserById(id)
        call.respond(user)
    }
}
```

### Итог
Delegated properties в серверном Kotlin — это мощный инструмент для:
- Уменьшения шаблонного кода.
- Реализации сложной логики инициализации и валидации.
- Интеграции с фреймворками (конфигурация, DI, HTTP-параметры).

Это делает код более читаемым, гибким и поддерживаемым.