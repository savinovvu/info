**Inline-классы (value-классы)** в Kotlin — это механизм для создания обёрток над значениями без дополнительных затрат памяти, которые обычно возникают при использовании обычных классов. Они обеспечивают типобезопасность и абстракцию, сохраняя производительность примитивных типов.

---

### **Как работают inline-классы?**
1. **Объявление**:  
   Используйте ключевое слово `value class` (до Kotlin 1.9 — `inline class` с экспериментальным статусом).
   ```kotlin
   @JvmInline
   value class Password(val value: String)
   ```

2. **Компиляция**:  
   Компилятор заменяет использование inline-класса на базовый тип (например, `String` для `Password`). Это происходит **на этапе компиляции**, поэтому в рантайме объекты не создаются:
   ```kotlin
   val secure = Password("secret") // В байт-коде используется строка "secret"
   ```

3. **Методы и свойства**:  
   Inline-классы могут содержать методы, свойства (только вычисляемые) и блоки `init`:
   ```kotlin
   value class Password(val value: String) {
       init { require(value.length >= 8) }
       val length: Int get() = value.length
       fun strength(): String = if (value.length > 12) "Strong" else "Weak"
   }
   ```

4. **Реализация интерфейсов**:  
   Inline-классы могут реализовывать интерфейсы, но при этом теряют преимущества инлайнинга в некоторых сценариях (например, при upcast к интерфейсу).

---

### **Ограничения inline-классов**
1. **Одно свойство в первичном конструкторе**:  
   Inline-класс должен иметь ровно одно свойство в конструкторе. С Kotlin 1.9+ разрешены несколько полей, но с ограничениями.

2. **Запрещены наследование и наследуемость**:  
   Inline-классы не могут наследовать другие классы и являются `final`.

3. **Невозможность хранения в heap как объекты**:  
   Они инлайнятся в базовый тип, но есть исключения (см. ниже).

4. **Запрещены некоторые структуры**:  
   Нельзя использовать `inner` классы, `var`-свойства с backing-полем, переопределять `equals`/`hashCode` (генерируются автоматически).

5. **Ограничения при использовании с nullable-типами и универсальными типами**:
   ```kotlin
   val nullablePassword: Password? = Password("") // Боксируется в объект!
   val list: List<Password> = listOf(Password("")) // Элементы боксируются.
   ```

---

### **Когда происходит боксирование (упаковка в объект)?**
Inlining не работает в случаях:
- **Nullable-типы**: `Password?`.
- **Универсальные типы**: `List<Password>`, `T where T : Password`.
- **При upcast к интерфейсу**: `val printable: Printable = Password("")`, где `Password` реализует `Printable`.

---

### **Примеры для серверного Kotlin**
1. **Типобезопасность идентификаторов**:
   ```kotlin
   @JvmInline
   value class UserId(val value: Long)
   value class ProjectId(val value: Long)

   fun getProject(projectId: ProjectId) { ... }

   // Ошибка компиляции: передать UserId вместо ProjectId нельзя
   getProject(UserId(42)) 
   ```

2. **Валидация данных**:
   ```kotlin
   value class Email(val value: String) {
       init { require(value.contains("@")) }
   }
   ```

3. **JSON-сериализация**:
   Inline-классы сериализуются как их базовый тип (например, в Jackson используйте `@JsonValue`):
   ```kotlin
   value class Email(val value: String)

   data class User(val email: Email)

   // Сериализуется в { "email": "test@example.com" }
   ```

---

### **Отличия от typealias**
- **Typealias** — это псевдоним типа, не обеспечивающий типобезопасность:
  ```kotlin
  typealias UserId = Long
  typealias ProjectId = Long
  val userId: UserId = 42L
  val projectId: ProjectId = userId // Компилируется, но логически неверно!
  ```
- **Inline-класс** — отдельный тип, предотвращающий случайную передачу неверного значения.

---

### **Итог**
Inline-классы — это эффективный способ добавить семантику и безопасность типов без потери производительности. Они идеальны для серверных приложений, где важны как читаемость кода, так и минимальные накладные расходы. Однако учитывайте ограничения, особенно при работе с nullable, коллекциями и интерфейсами.