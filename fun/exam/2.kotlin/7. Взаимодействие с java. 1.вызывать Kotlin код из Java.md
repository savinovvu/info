Взаимодействие между Kotlin и Java в серверной разработке происходит практически бесшовно благодаря полной бинарной совместимости. Рассмотрим оба направления:

### 1. Вызов Kotlin из Java

#### Основные правила:
- **Классы и методы**: Kotlin-классы и методы доступны в Java напрямую, но есть нюансы с именованием.
- **Свойства**: Kotlin-свойства превращаются в геттеры/сеттеры (например, `val name` → `getName()`, `var age` → `getAge()`/`setAge()`).
- **Пакеты**: Kotlin-файлы должны быть в том же пакете, что и Java-код.

#### Примеры:

**Kotlin класс:**
```kotlin
// User.kt
class User(val name: String, var age: Int) {
    fun isAdult() = age >= 18
}
```

**Вызов из Java:**
```java
// Java код
User user = new User("Alex", 25);
System.out.println(user.getName()); // Геттер для val
user.setAge(26); // Сеттер для var
boolean isAdult = user.isAdult();
```

#### Особые случаи:

1. **Top-level функции** (Kotlin):
   ```kotlin
   // Utils.kt
   fun formatMessage(text: String) = "Message: $text"
   ```
   В Java превращается в статический метод класса `UtilsKt`:
   ```java
   String msg = UtilsKt.formatMessage("Hello");
   ```

2. **Companion Object**:
   ```kotlin
   class MyClass {
       companion object {
           fun create() = MyClass()
       }
   }
   ```
   В Java:
   ```java
   MyClass instance = MyClass.Companion.create();
   // Если добавить @JvmStatic:
   // MyClass instance = MyClass.create();
   ```

3. **Имена файлов**: Можно изменить с помощью `@file:JvmName("MyUtils")` в Kotlin-файле.

4. **Null-безопасность**: Аннотации `@Nullable`/`@NotNull` генерируются автоматически на основе типов Kotlin.

---

### 2. Вызов Java из Kotlin

#### Прямой вызов:
Большинство Java-классов работают в Kotlin "как есть".

**Пример Java-класса:**
```java
// JavaService.java
public class JavaService {
    public String processData(String input) {
        return "Processed: " + input;
    }
}
```

**Использование в Kotlin:**
```kotlin
val service = JavaService()
val result = service.processData("data")
```

#### Особенности:

1. **Геттеры/Сеттеры** Java становятся свойствами Kotlin:
   ```java
   // В Java
   public class Person {
       private String name;
       public String getName() { return name; }
   }
   ```
   ```kotlin
   // В Kotlin
   val person = Person()
   println(person.name) // Доступ к геттеру как к свойству
   ```

2. **Проверяемые исключения** (checked exceptions) игнорируются в Kotlin.

3. **SAM-интерфейсы**:
   ```java
   // Java
   public interface Runnable {
       void run();
   }
   ```
   ```kotlin
   // Kotlin
   val runnable = Runnable { println("Running") }
   ```

---

### Практические советы для серверной разработки:

1. **Spring Boot**:
    - Смешивайте Kotlin и Java в одном проекте.
    - Kotlin-классы можно использовать в Spring-бинах наравне с Java.

2. **Аннотации JVM**:
    - `@JvmStatic` – для создания статических методов.
    - `@JvmOverloads` – для генерации перегруженных версий методов.
    - `@JvmField` – чтобы exposed поле напрямую.

3. **Сборка**:
    - Maven/Gradle автоматически компилируют оба языка.
    - Пример Gradle:
      ```gradle
      plugins {
          kotlin("jvm") version "1.9.0"
      }
      dependencies {
          implementation(kotlin("stdlib"))
      }
      ```

4. **Null-безопасность**:
    - Используйте аннотации `@Nullable` и `@NotNull` в Java-коде для лучшей интеграции.

---

### Пример смешанного проекта (Spring Boot):

**Java-сервис:**
```java
@Service
public class JavaUserService {
    public User findUser(Long id) { ... }
}
```

**Kotlin-контроллер:**
```kotlin
@RestController
class UserController(@Autowired val userService: JavaUserService) {
    @GetMapping("/user/{id}")
    fun getUser(@PathVariable id: Long) = userService.findUser(id)
}
```

**Kotlin-расширение для Java-класса:**
```kotlin
fun JavaUserService.findActiveUser(id: Long) = 
    findUser(id)?.takeIf { it.isActive }
```

Таким образом, вы можете постепенно мигрировать с Java на Kotlin или использовать оба языка в одном проекте, выбирая лучшие инструменты для каждой задачи.