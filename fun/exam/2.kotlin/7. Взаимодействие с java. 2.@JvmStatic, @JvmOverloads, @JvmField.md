Аннотации `@JvmStatic`, `@JvmOverloads` и `@JvmField` в Kotlin используются для улучшения взаимодействия с JVM и совместимости с Java-кодом. Вот подробное объяснение каждой из них:

---

### 1. `@JvmStatic`
**Что это?**  
Аннотация, которая указывает компилятору сгенерировать статический метод для функции или свойства, объявленного в `companion object` или `object`.

**Когда используется?**
- Когда нужно вызвать Kotlin-метод из Java как статический метод (вместо обращения через экземпляр компаньон-объекта).
- Для интеграции с библиотеками/фреймворками, которые требуют статических методов (например, Spring DI, JUnit).

**Пример:**
```kotlin
class MyService {
    companion object {
        @JvmStatic
        fun create(): MyService = MyService()
    }
}
```
**В Java:**
```java
// Без @JvmStatic: MyService.Companion.create();
// С @JvmStatic:
MyService.create(); // Упрощенный вызов
```

---

### 2. `@JvmOverloads`
**Что это?**  
Аннотация, которая генерирует перегруженные версии функции для параметров со значениями по умолчанию, чтобы их можно было использовать из Java.

**Когда используется?**
- Когда Kotlin-функция имеет параметры со значениями по умолчанию, и нужно избежать необходимости передавать все аргументы в Java.
- Удобно для создания билдеров или упрощения API в Java.

**Пример:**
```kotlin
class HttpClient @JvmOverloads constructor(
    host: String,
    port: Int = 8080,
    timeout: Int = 1000
) { ... }
```
**В Java:**
```java
// Генерируются конструкторы:
new HttpClient("api.service.com");
new HttpClient("api.service.com", 8080);
new HttpClient("api.service.com", 8080, 1000);
```

---

### 3. `@JvmField`
**Что это?**  
Аннотация, которая отключает геттеры/сеттеры для свойства и предоставляет к нему прямой доступ как к полю (field).

**Когда используется?**
- Когда требуется публичное поле без инкапсуляции (например, для констант).
- Для совместимости с фреймворками, которые работают с полями напрямую (например, JPA, Jackson, Spring).
- В `data class` для упрощения доступа к свойствам.

**Пример:**
```kotlin
class User {
    @JvmField
    val id: String = "default"
}
```
**В Java:**
```java
User user = new User();
String id = user.id; // Прямой доступ, без user.getId()
```

---

### Особенности в серверном Kotlin
1. **Совместимость с фреймворками:**  
   Аннотации критичны для интеграции с Java-библиотеками (например, Spring Boot, JUnit, Jackson). Без `@JvmStatic` тесты JUnit 4 не найдут статические методы, а без `@JvmField` Spring может не inject-ить зависимости.

2. **Производительность:**  
   `@JvmField` избегает вызова геттеров, что может немного ускорить доступ к данным.

3. **Константы:**  
   Для публичных констант в `companion object` используйте `const val`, который автоматически становится статическим полем в Java. `@JvmField` подходит для не-примитивных свойств.

**Пример константы:**
```kotlin
companion object {
    const val API_VERSION = "1.0"
}
```

---

### Итог
- **`@JvmStatic`**: Делает методы статическими для Java.
- **`@JvmOverloads`**: Генерирует перегруженные методы для параметров со значениями по умолчанию.
- **`@JvmField`**: Предоставляет прямой доступ к полям без геттеров/сеттеров.

Используйте эти аннотации, когда ваш Kotlin-код должен быть удобным для вызова из Java или работать с Java-ориентированными фреймворками.