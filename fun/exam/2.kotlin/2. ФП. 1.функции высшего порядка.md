**Функции высшего порядка** (higher-order functions) — это функции, которые принимают другие функции в качестве параметров и/или возвращают функции как результат. Они являются ключевой концепцией функционального программирования и активно используются в Kotlin.

### Основные характеристики:
1. **Принимают функции как параметры**
2. **Возвращают функции как результат**

---

### Пример 1: Функция как параметр
```kotlin
// Функция высшего порядка
fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

// Обычные функции или лямбды
fun add(x: Int, y: Int) = x + y
val multiply = { x: Int, y: Int -> x * y }

// Использование
fun main() {
    val result1 = calculate(5, 3, ::add) // Передаем ссылку на функцию
    val result2 = calculate(5, 3, multiply) // Передаем лямбду
    val result3 = calculate(5, 3) { a, b -> a - b } // Передаем лямбду напрямую
    
    println("$result1, $result2, $result3") // 8, 15, 2
}
```

---

### Пример 2: Функция как возвращаемое значение
```kotlin
// Функция возвращает другую функцию
fun getOperator(operation: String): (Int, Int) -> Int {
    return when (operation) {
        "add" -> { a, b -> a + b }
        "multiply" -> { a, b -> a * b }
        else -> throw IllegalArgumentException("Unknown operation")
    }
}

// Использование
fun main() {
    val adder = getOperator("add")
    val multiplier = getOperator("multiply")
    
    println(adder(2, 3)) // 5
    println(multiplier(2, 3)) // 6
}
```

---

### Пример 3: Стандартные функции высшего порядка в Kotlin
```kotlin
// Серверный пример: обработка списка пользователей
data class User(val id: Int, val name: String, val isActive: Boolean)

fun processUsers(users: List<User>) {
    // filter (принимает функцию-предикат)
    val activeUsers = users.filter { it.isActive }
    
    // map (принимает функцию преобразования)
    val userNames = activeUsers.map { it.name }
    
    // forEach (принимает действие)
    userNames.forEach { println("User: $it") }
    
    // fold (принимает аккумулятор и функцию)
    val totalChars = userNames.fold(0) { acc, name -> acc + name.length }
}

// Использование с кастомной логикой
fun findUserById(users: List<User>, predicate: (User) -> Boolean): User? {
    return users.find(predicate)
}

fun main() {
    val users = listOf(
        User(1, "Alice", true),
        User(2, "Bob", false),
        User(3, "Charlie", true)
    )
    
    // Передача лямбды как параметра
    val user = findUserById(users) { it.id == 2 }
}
```

---

### Преимущества в серверном Kotlin:
1. **Абстракция поведения** — Можно инкапсулировать общую логику (например, повторы, транзакции)
2. **Гибкость** — Легко менять поведение без создания новых классов
3. **Лаконичность** — Сокращение шаблонного кода
4. **Композиция** — Возможность строить сложную логику из простых функций

```kotlin
// Пример для серверной логики: обработка с повторами
fun <T> withRetry(
    maxAttempts: Int = 3,
    operation: () -> T
): T {
    var lastException: Throwable?
    repeat(maxAttempts) { attempt ->
        try {
            return operation()
        } catch (e: Exception) {
            lastException = e
            println("Attempt $attempt failed: ${e.message}")
        }
    }
    throw lastException!!
}

// Использование
fun fetchDataFromAPI() {
    val result = withRetry(3) {
        // Логика вызова API
        "Данные с сервера"
    }
}
```

Функции высшего порядка делают код более декларативным, переиспользуемым и выразительным, что особенно важно в серверной разработке для создания гибкой и поддерживаемой архитектуры.